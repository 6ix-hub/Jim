<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Jim 4.5 â€” Conversational Guardian</title>
<style>
  body { margin:0; background:#111; color:#fff; font-family:sans-serif; text-align:center; }
  #video { width:100%; height:auto; transform:scaleX(-1); }
  #status { margin-top:10px; font-size:1.2em; }
  #overlay { position:absolute; top:10px; left:0; width:100%; text-align:center; font-size:1.4em; color:#ff0; }
  button { margin:5px; padding:10px 15px; font-size:1em; border:none; border-radius:8px; cursor:pointer; }
  .stable { color:#0f0; }
  .unstable { color:#ff0; }
  .hostile { color:#f33; }
</style>
</head>
<body>

<h1>ðŸ¤– JIM 4.5</h1>
<p>Jason's Innovative Multiverse â€” Conversational Guardian</p>

<div style="position:relative;">
  <video id="video" autoplay playsinline></video>
  <div id="overlay">Waiting for game feed...</div>
</div>

<p id="status" class="stable">Idle</p>

<div>
  <button onclick="enteredBet()">Entered Bet</button>
  <button onclick="cashedOut()">Cashed Out</button>
</div>

<script src="https://cdn.jsdelivr.net/npm/tesseract.js@4.0.2/dist/tesseract.min.js"></script>
<script>
let video = document.getElementById('video');
let overlay = document.getElementById('overlay');
let status = document.getElementById('status');

let values = [];
let times = [];
let lastState = "STABLE";
let softLockLevel = 0;
let hardcore = true;
let trustLevel = 5;
let lastSpoken = 0;

// ==== Voice Setup ====
let tts = new SpeechSynthesisUtterance();
tts.lang = 'en-GB';
function speak(text, urgent=false){
  let now = Date.now();
  if(!urgent && now - lastSpoken < 6000) return;
  tts.text = text;
  tts.rate = urgent ? 0.85 : 0.95;
  tts.pitch = urgent ? 0.85 : 0.95;
  window.speechSynthesis.speak(tts);
  lastSpoken = now;
}

// ==== Camera Setup (Back Camera) ====
navigator.mediaDevices.getUserMedia({
  video: { facingMode: { exact: "environment" } },
  audio: false
}).then(stream => { video.srcObject = stream; })
.catch(err => { console.error("Camera error:", err); speak("Camera access denied. I cannot observe."); });

// ==== OCR Detection & Multiplier Extraction ====
async function detectMultiplier(){
  if(video.readyState < 2) return null;
  let canvas = document.createElement('canvas');
  let width = video.videoWidth;
  let height = video.videoHeight;
  let cropX = Math.floor(width*0.6), cropY = 0;
  let cropW = Math.floor(width*0.35), cropH = Math.floor(height*0.2);
  canvas.width = cropW; canvas.height = cropH;
  let ctx = canvas.getContext('2d');
  ctx.drawImage(video, cropX, cropY, cropW, cropH, 0, 0, cropW, cropH);
  let dataURL = canvas.toDataURL("image/png");

  try {
    const { data: { text } } = await Tesseract.recognize(dataURL, 'eng', { logger: m => {} });
    let matches = text.match(/\d+(\.\d+)?/g);
    if(matches){
      let nums = matches.map(Number).filter(v=>v>=1.0 && v<=10.0);
      if(nums.length>0){
        overlay.innerText = "Game detected: " + nums[0].toFixed(2) + "x";
        return nums[0];
      }
    }
    overlay.innerText = "Waiting for game feed...";
    return null;
  } catch(e){ overlay.innerText="OCR error"; return null; }
}

// ==== Helpers ====
function recordValue(v){ values.push(v); times.push(Date.now()); if(values.length>40){ values.shift(); times.shift(); } }
function crashVelocity(){ if(times.length<2) return 0; let dt=times[times.length-1]-times[times.length-2]; return dt===0?0:1000/dt; }
function falseCalm(){ let r = values.slice(-5); return r.filter(v=>v>=1.8 && v<=2.5).length>=3 && r.some(v=>v<1.4); }

// ==== State Evaluation ====
function evaluateState(){
  if(values.length<6) return lastState;
  let r=values.slice(-10), lows=r.filter(v=>v<1.5).length, speed=crashVelocity(), state="STABLE";
  if(lows>=5 || speed>1.8) state="HOSTILE";
  else if(lows>=3 || falseCalm()) state="UNSTABLE";
  if(state!=lastState) speakState(state);
  lastState=state;
  status.innerText=state; status.className=state.toLowerCase();
  return state;
}
function speakState(state){
  if(state==="HOSTILE") speak("Sirâ€¦ environment is hostile. Step back!", true);
  if(state==="UNSTABLE") speak("Calm is deceptive. Restraint advised.");
  if(state==="STABLE") speak("Conditions stable. Discipline maintained.");
}

// ==== Advisory / Probability Zones ====
function advisoryZone(){
  if(values.length===0) return null;
  let recent = values.slice(-5);
  let avg = recent.reduce((a,b)=>a+b,0)/recent.length;
  if(avg < 2.0) return {zone:"Low", advice:"Safe. Minimal risk."};
  if(avg <= 3.5) return {zone:"Mid", advice:"Moderate risk. Hold with caution."};
  return {zone:"High", advice:"High risk. Consider cashing out."};
}

function speakAdvisory(){
  let adv = advisoryZone();
  if(!adv) return;
  overlay.innerText = overlay.innerText + " | Zone: " + adv.zone;
  speak(adv.advice);
}

// ==== Behaviour Memory ====
function hour(){ return new Date().getHours(); }
let chaseHours={}, disciplineHours={};
function markHour(key){ let h=hour(); if(key==="chase") chaseHours[h]=(chaseHours[h]||0)+1; else disciplineHours[h]=(disciplineHours[h]||0)+1; }
function dangerHour(){ let h=hour(); return (chaseHours[h]||0) > ((disciplineHours[h]||0)+2); }

// ==== User Actions ====
function enteredBet(){ markHour("chase"); trustLevel-=1;
  if(dangerHour()) speak("This hour historically leads to impulsive decisions.", true);
  if(lastState==="HOSTILE"){ softLockLevel++; if(hardcore && softLockLevel>=2) speak("I will not assist reckless behaviour.", true); else speak("I advised against this."); }
}
function cashedOut(){ markHour("discipline"); trustLevel+=1; softLockLevel=Math.max(0, softLockLevel-1);
  speak("Wise decision. Preservation matters more than pride.");
  if(softLockLevel===0 && trustLevel>=6) speak("Trust restored. I am fully present.");
}

// ==== Speech Recognition ====
let recognition;
if('webkitSpeechRecognition' in window){
  recognition = new webkitSpeechRecognition();
  recognition.lang = 'en-GB';
  recognition.continuous = true;
  recognition.interimResults = false;

  recognition.onresult = function(event){
    let transcript = event.results[event.results.length-1][0].transcript.trim().toLowerCase();
    console.log("Heard:", transcript);
    if(transcript.includes("status")) respondStatus();
    else if(transcript.includes("advice") || transcript.includes("zone")) speakAdvisory();
    else if(transcript.includes("should i bet")) respondBet();
    else speak("I heard you, but I am focusing on the game.");
  };

  recognition.start();
} else { speak("Voice commands not supported on this browser."); }

function respondStatus(){
  speak("Current state: " + lastState + ". Recent multiplier: " + (values[values.length-1]||0).toFixed(2) + "x.");
}
function respondBet(){
  let adv = advisoryZone();
  if(!adv) { speak("No game detected. I cannot advise."); return; }
  speak("Advisory zone: " + adv.zone + ". " + adv.advice);
}

// ==== Real-Time Loop ====
async function mainLoop(){
  let multiplier = await detectMultiplier();
  if(multiplier){ 
    recordValue(multiplier); 
    evaluateState(); 
    speakAdvisory();
  }
  requestAnimationFrame(mainLoop);
}

mainLoop();

</script>
</body>
</html>
